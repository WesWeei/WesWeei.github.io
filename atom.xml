<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WesWei&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/b5d59e139d0fc9b99377a178d628f45e</icon>
  
  <link href="https://blog.weswei.com/atom.xml" rel="self"/>
  
  <link href="https://blog.weswei.com/"/>
  <updated>2022-12-17T14:55:18.605Z</updated>
  <id>https://blog.weswei.com/</id>
  
  <author>
    <name>WesWei</name>
    <email>wesustc@mail.ustc.edu.cn</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构-散列表</title>
    <link href="https://blog.weswei.com/2022/12/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    <id>https://blog.weswei.com/2022/12/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%A3%E5%88%97%E8%A1%A8/</id>
    <published>2022-12-17T14:29:42.000Z</published>
    <updated>2022-12-17T14:55:18.605Z</updated>
    
    <content type="html"><![CDATA[<p>本笔记参考自<strong>鱼C-小甲鱼</strong>的<a href="https://www.bilibili.com/video/BV1jW411K7yg/?p=84&amp;share_source=copy_web&amp;vd_source=f22223129f65cdce91eba365f1c2bbc8"><strong>【C语言描述】《数据结构和算法》</strong></a></p><h1>散列表的查找</h1><blockquote><p>散列表，又称哈希表<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mi>M</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">HashMap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span></p></blockquote><h2 id="散列表的查找原理">散列表的查找原理</h2><p>先回顾查找关键字的方法：</p><ul><li>顺序表查找：逐个比较</li><li>有序表查找：二分法比较</li></ul><p>散列表查找？直接经过哈希函数映射</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>L</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>K</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Location = f(Key)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">oc</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">Key</span><span class="mclose">)</span></span></span></span></span></p><p>将关键字<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>K</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(Key)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">Key</span><span class="mclose">)</span></span></span></span>输入散列函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>中，输出结果即为存储位置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>L</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(Location)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">L</span><span class="mord mathnormal">oc</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p><p>免去了大量的比较迭代过程，经过一次数学运算便能得到关键字的存储位置</p><h2 id="散列表的查找步骤">散列表的查找步骤</h2><ul><li>当存储记录时，通过散列函数计算出记录的散列地址</li><li>当查找记录时，同样通过散列函数计算出记录的散列地址，并根据此地址访问该记录</li></ul><h1>散列函数的构造</h1><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRGoodHash(好的散列函数)EasyCal(计算简单)EvenlyDistributed(分布均匀)GoodHash--&gt;EasyCalGoodHash--&gt;EvenlyDistributed  </pre></div><h2 id="直接定址法">直接定址法</h2><blockquote><p>简单的线性计算</p></blockquote><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>K</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>×</mo><mi>K</mi><mi>e</mi><mi>y</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f(Key)= a\times Key + b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">Key</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">Key</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span></p><p><strong>适合情况：</strong></p><ul><li>关键字分布连续且均匀</li></ul><h2 id="数字分析法">数字分析法</h2><blockquote><p>分析关键字后抽取其中几位作为散列地址</p></blockquote><p>例如要存储公司员工登记表，选择以手机号作为关键字对手机号分析我们有</p><table><thead><tr><th style="text-align:center">运营商接入号</th><th style="text-align:center">HLR识别码</th><th style="text-align:center">用户编号</th></tr></thead><tbody><tr><td style="text-align:center">130</td><td style="text-align:center">xxxx</td><td style="text-align:center">1234</td></tr></tbody></table><p>发现前七位相同的概率极高，所以抽取最后四位数字作为散列地址是不错的选择</p><p><strong>适合情况：</strong></p><ul><li>关键字为数字且位数比较大</li></ul><h2 id="平方取中法">平方取中法</h2><blockquote><p>将关键字平方之后取中间若干位数字作为散列地址</p></blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>123</mn><msup><mn>4</mn><mn>2</mn></msup><mo>=</mo><mn>1522756</mn></mrow><annotation encoding="application/x-tex">1234^2=1522756</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">123</span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1522756</span></span></span></span>，取227</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>432</mn><msup><mn>1</mn><mn>2</mn></msup><mo>=</mo><mn>18671041</mn></mrow><annotation encoding="application/x-tex">4321^2=18671041</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">432</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">18671041</span></span></span></span>，取671或710或6710</p><p><strong>适合情况：</strong></p><ul><li>事先不知道关键字的分布情况</li><li>关键字为数字</li><li>关键字位数不大，否则平方运算会花费大量时间</li></ul><h2 id="折叠法">折叠法</h2><blockquote><p>将关键字从左到右分割成位数相等的几部分</p><p>将这几部分叠加求和</p><p>按散列表表长取后几位作为散列地址</p></blockquote><p>例如一个表长为1000的散列表，只需3位数字即可表示散列地址，其中某个关键字为987654321000，则</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>987654321000</mn></mrow><annotation encoding="application/x-tex">987654321000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">987654321000</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>↓</mo></mrow><annotation encoding="application/x-tex">\downarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mrel">↓</span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>987</mn><mo>+</mo><mn>654</mn><mo>+</mo><mn>321</mn><mo>+</mo><mn>000</mn><mo>=</mo><mn>1962</mn></mrow><annotation encoding="application/x-tex">987+654+321+000=1962</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">987</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">654</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">321</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">000</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1962</span></span></span></span></span></p><p>取962为散列地址</p><p><strong>适合情况：</strong></p><ul><li>关键字为数字且位数比较多</li></ul><h2 id="除留余数法">除留余数法</h2><blockquote><p>此方法为最常用的构造散列函数的方法，对于散列表长为m的散列函数的计算公式为</p></blockquote><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>K</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>K</mi><mi>e</mi><mi>y</mi><mtext> </mtext><mi>M</mi><mi>O</mi><mi>D</mi><mtext> </mtext><mi>p</mi><mtext> </mtext><mo stretchy="false">(</mo><mi>p</mi><mo>≤</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(Key)=Key\ MOD\ p\ (p\leq m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">Key</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">Key</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">MO</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace"> </span><span class="mord mathnormal">p</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></p><blockquote><p>事实上，这个方法不仅可以对关键字直接取模，也可以通过折叠、平方取中后再取模</p></blockquote><p><strong>这里要注意<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span></span></span></span>的取值：</strong></p><ul><li>大部分应该取不大于m但最接近或等于m的<strong>素数</strong></li></ul><h2 id="随机数法">随机数法</h2><blockquote><p>选择一个随机数，取关键字的随机函数值为它的散列地址</p></blockquote><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>K</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mi>K</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(Key)=random(Key)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">Key</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">Key</span><span class="mclose">)</span></span></span></span></span></p><p><strong>适合情况：</strong></p><ul><li>当关键字的长度不等时，比较适合</li></ul><h2 id="总结">总结</h2><p><strong>1. 当关键字为字母、特殊字符、字符串时：</strong></p><p>对ASCII码或UniCode编码进行上述的散列运算操作</p><p><strong>2. 视不同的情况采用不同的散列函数</strong></p><p>常见考虑方向：</p><ul><li>计算散列地址所需的时间</li><li>关键字的长度</li><li>散列表的大小</li><li>关键字的分布情况</li><li>记录查找的频率</li></ul><h1>散列函数的冲突解决</h1><blockquote><p>由于散列函数是将范围较大的数据集映射到范围较小的地址集，散列函数设计得再好，也难以完全避免冲突</p></blockquote><h2 id="开放定址法">开放定址法</h2><blockquote><p>当发生冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录插入</p></blockquote><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>K</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>K</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>d</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mtext> </mtext><mi>M</mi><mi>O</mi><mi>D</mi><mtext> </mtext><mi>m</mi><mtext> </mtext><mo stretchy="false">(</mo><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_i(Key)=(f(Key)+d_i)\ MOD\ m\ (d_i=1,2,...,m-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">Key</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">Key</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.02778em;">MO</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace"> </span><span class="mord mathnormal">m</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8389em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p>但是这样的方法比较盲目，容易产生堆积现象（记录集中在某个区域而其他区域空白），可以通过改变<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的取值方式来解决：</p><h3 id="1-使用平方运算">1. 使用平方运算</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><msup><mn>1</mn><mn>2</mn></msup><mo separator="true">,</mo><mo>−</mo><msup><mn>1</mn><mn>2</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><mo>−</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msup><mi>q</mi><mn>2</mn></msup><mo separator="true">,</mo><mo>−</mo><msup><mi>q</mi><mn>2</mn></msup><mo separator="true">,</mo><mi>q</mi><mo>&lt;</mo><mo>=</mo><mfrac><mi>m</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">d_i=1^2,-1^2,2^2,-2^2,...,q^2,-q^2,q&lt;=\frac{m}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0585em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.7936em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1076em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h3 id="2-使用随机函数">2. 使用随机函数</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub><mo>=</mo><mi>r</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>o</mi><mi>m</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d_i = random(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">an</span><span class="mord mathnormal">d</span><span class="mord mathnormal">o</span><span class="mord mathnormal">m</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span></span></p><p>即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是由一个随机函数获得的数列</p><h2 id="再散列函数法">再散列函数法</h2><blockquote><p>准备多个散列函数，当冲突时尝试调用下一个散列函数</p></blockquote><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>K</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>R</mi><msub><mi>H</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>K</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_i(Key)=RH_i(Key),(i=1,2,3,...,k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">Key</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0813em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">Key</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></span></p><h2 id="链地址法">链地址法</h2><blockquote><p>在地址指向的位置，不直接存放数据，而是存放指向数据的指针，当冲突时，插入链表即可</p></blockquote><p><img src="/photo/LinkLocation.png" alt=""></p><h2 id="公共溢出区法">公共溢出区法</h2><blockquote><p>与链地址类似，但采用了一个新表（溢出表）来存放冲突的数据</p></blockquote><p><img src="/photo/OverflowTable.png" alt=""></p><h1>散列表查找的代码实现</h1><blockquote><p>哈希表在C语言中的具体实现</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HASHSIZE 10<span class="comment">//宏定义哈希表大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASHM 7<span class="comment">//根据哈希表大小定义取模数M</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR -1<span class="comment">//错误</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 0<span class="comment">//成功</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLKEY -32768<span class="comment">//一般定义为不可能出现的关键字</span></span></span><br><span class="line"><span class="comment">//---散列表数据结构的定义---</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> *elem; <span class="comment">//数据元素的基址，利于动态分配数组</span></span><br><span class="line">    <span class="type">int</span> count; <span class="comment">//当前散列表的大小</span></span><br><span class="line">&#125;HashTable;</span><br><span class="line"><span class="comment">//---构造新的散列表---</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InitHashTable</span><span class="params">(HashTable *H)</span></span><br><span class="line">&#123;</span><br><span class="line">    H-&gt;count = HASHSIZE;</span><br><span class="line">    H-&gt;elem = (<span class="type">int</span> *)<span class="built_in">malloc</span>(HASHSIZE*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(!H-&gt;elem)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; HASHTABLE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        H-&gt;elem[i] = NULLKEY;<span class="comment">//初始化为默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---除留余数法散列函数定义---</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash</span><span class="params">(<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> key % HASHM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---插入关键字---</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertHash</span><span class="params">(HashTable *H, <span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> addr;</span><br><span class="line">    addr = Hash(key);</span><br><span class="line">    <span class="keyword">while</span>(H-&gt;elem[addr] != NULLKEY)<span class="comment">//出现冲突</span></span><br><span class="line">    &#123;</span><br><span class="line">        addr = (addr + <span class="number">1</span>) % HASHM; <span class="comment">//利用开放定址法的线性探测</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到空位，将关键字存入</span></span><br><span class="line">    H-&gt;elem[addr] = key;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---查找关键字---</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">SearchHash</span><span class="params">(HashTable H,<span class="type">int</span> key, <span class="type">int</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    *addr = Hash(key);</span><br><span class="line">    <span class="keyword">while</span>(H.elem[*addr] != key)<span class="comment">//出现冲突</span></span><br><span class="line">    &#123;</span><br><span class="line">        *addr = (*addr + <span class="number">1</span>) % HASHM;<span class="comment">//同样利用开放定址法的线性探测处理冲突</span></span><br><span class="line">        <span class="keyword">if</span>(H.elem[*addr] == NULLKEY || *addr == Hash(key))</span><br><span class="line">        <span class="comment">//找到空位或者回到原点，说明查找失败</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到关键字则在上述过程中地址已存到addr中</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本笔记参考自&lt;strong&gt;鱼C-小甲鱼&lt;/strong&gt;的&lt;a href=&quot;https://www.bilibili.com/video/BV1jW411K7yg/?p=84&amp;amp;share_source=copy_web&amp;amp;vd_source=f2222312</summary>
      
    
    
    
    <category term="笔记" scheme="https://blog.weswei.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据结构" scheme="https://blog.weswei.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>评论测试</title>
    <link href="https://blog.weswei.com/2022/12/15/%E8%AF%84%E8%AE%BA%E6%B5%8B%E8%AF%95/"/>
    <id>https://blog.weswei.com/2022/12/15/%E8%AF%84%E8%AE%BA%E6%B5%8B%E8%AF%95/</id>
    <published>2022-12-15T10:13:25.000Z</published>
    <updated>2022-12-16T15:59:49.372Z</updated>
    
    <content type="html"><![CDATA[<h1>这是一篇用来测试评论区功能的文章</h1><h2 id="用户信息栏说明">用户信息栏说明</h2><ul><li>昵称：填写自己喜欢的昵称</li><li>邮箱：填写自己的常用邮箱，使用qq邮箱可自动抓取qq头像</li><li>网址：暂时没什么用，可以不填</li></ul><h2 id="评论编辑栏说明">评论编辑栏说明</h2><ul><li>表情：可在评论中添加表情</li><li>图片：可在评论中插入图片<s>不要插入太大的图片不然服务器压力有亿点大</s></li><li>预览：Markdown语法编辑预览</li></ul><p>不了解Markdown语法? 点击<a href="https://www.bilibili.com/video/BV1JA411h7Gw/?share_source=copy_web&amp;vd_source=f22223129f65cdce91eba365f1c2bbc8">这里</a>开始学习</p><h2 id="Markdown语法预览效果">Markdown语法预览效果</h2><p><img src="/photo/MarkdownPreview.PNG" alt=""></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;这是一篇用来测试评论区功能的文章&lt;/h1&gt;
&lt;h2 id=&quot;用户信息栏说明&quot;&gt;用户信息栏说明&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;昵称：填写自己喜欢的昵称&lt;/li&gt;
&lt;li&gt;邮箱：填写自己的常用邮箱，使用qq邮箱可自动抓取qq头像&lt;/li&gt;
&lt;li&gt;网址：暂时没什么用，可以不填&lt;</summary>
      
    
    
    
    <category term="笔记" scheme="https://blog.weswei.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="测试" scheme="https://blog.weswei.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>WesWeiBlog诞生记</title>
    <link href="https://blog.weswei.com/2022/11/21/WesWeiBlog%E8%AF%9E%E7%94%9F%E8%AE%B0/"/>
    <id>https://blog.weswei.com/2022/11/21/WesWeiBlog%E8%AF%9E%E7%94%9F%E8%AE%B0/</id>
    <published>2022-11-21T08:05:32.000Z</published>
    <updated>2022-12-04T15:11:23.920Z</updated>
    
    <content type="html"><![CDATA[<h1>前言</h1><p>期中考试周终于结束了😇</p><p>此处应该配图</p><div class="fj-gallery"><p><img src="/photo/kddzc.jpg" alt=""></p>          </div><p>其实这篇文章断断续续写了好久，复习累了就摸鱼码两个字。</p><p>考完试脑子不接受任何知识的摄入，于是摆大烂把这篇文章一口气写完了。</p><h1>绪</h1><h2 id="这是一篇有关WesWeiBlog诞生的短记。">这是一篇有关WesWeiBlog诞生的短记。</h2><p>**每个第一次总是有意义的。**更何况，这是我第一个属于自己的域名，第一个属于自己的网站，第一个属于自己的博客。这第一篇文章，自然而然地，具有相当的纪念意义。我又想到，创建这个小站的过程本就是一件值得记录的事情，于是顺理成章地，我码下了这段文字，作为第一个分享给你的故事，也籍此纪念<a href="https://blog.weswei.com/">WesWeiBlog</a>的诞生。</p><h1>缘与源</h1><p>其实曾经我并不是一个喜欢做记录的人，中学期间，我几乎不怎么发过动态，朋友圈，也不曾写过什么日记，周记。</p><p>高考结束，在匆忙却又充实的中学生活结束后，长达三个月的长假显得非常空虚。各种在高考前，算计好考完后要做的事情似乎也变得没那么吸引人。也正是这时候，有了更多的时间去看朋友圈，了解朋友们有趣的故事与生活。</p><p>所以我想，为何不把朋友圈当做一个随时随地可以翻阅的公开记事本，把我的生活分享给朋友们呢。于是，在<strong>2021年8月12日</strong>，我发出了人生中第一条朋友圈。<s>如果你在我的微信列表，并且愿意翻，应该还能翻到</s></p><p>偶尔我也会去翻翻以前自己发的朋友圈，感觉回忆一下以前的生活也蛮有意思的（笑）。这大概也算是发挥了一些日记的作用？<s>小学曾经尝试过每天写日记，但是由于大部分都是流水账，坚持不到两周就放弃了</s></p><p>但是慢慢地我觉得朋友圈似乎也不是很能满足我的需求。有时候想要写一写长文（比如这篇就是），朋友圈的排版又过于简单。<s>例如排版只能靠换行</s></p><p>于是，我就有了写博客的想法。</p><h1>抉择</h1><p>想法有了，载体用什么似乎又成了一个难题。</p><p>最初的想法其实是创建一个公众号。因为高中时期就曾读过一些朋友们的公众号文章，观感良好，感觉非常适合写长文。但是，我又觉得，公众号不够灵活（缺少真正属于个人的感觉？）</p><p>一个偶然的机会，在参加HackerGame2022的时候，看到一些排行榜上面的大佬名字后面都带有一个网址，我才了解到个人博客这样一个非常适合记录生活，分享技术的方式。</p><p>恰好，我是一个非常热爱折腾的人，于是，萌生了建立一个属于自己的个人博客的想法。<s>不觉得这很酷吗?作为一名理工男我觉得这太酷了，很符合我对未来生活的想象，科技并带着趣味</s></p><h1>折腾</h1><p>既然有了想法，那就着手付诸实践。<br>于是我便开始了解如何搭建一个博客。</p><h2 id="域名">域名</h2><p>域名通俗来说就是浏览器最顶上框框的那个网址。</p><p>世界上的每一个网站都有一个对应的形如<strong>192.168.0.1(IPv4)<strong>或者</strong>1002:003B:456C:678D:890E:0012:234F:56G7(IPv6)<strong>的</strong>IP地址</strong>。但是这样的一串字符过于抽象，难以记忆和分享。所以我们需要一个更加形象容易记住的代名词。</p><p>而域名就担任了这样一个功能。比如我们经常见到的诸如<a href="https://www.baidu.com/">www.baidu.com</a>，<a href="https://www.google.com/">www.google.com</a>这样的网址，就是域名。这个网站是我的博客，于是我便在<a href="https://www.huaweicloud.com/">华为云</a>租赁了<a href="https://blog.weswei.com/">blog.weswei.com</a>这样一个一看就知道是WesWei博客的域名。</p><h2 id="框架">框架</h2><p>域名有了，但是我不太懂怎么写网页代码，怎么办呢？答案是，找前人写的轮子。</p><p>于是我凭着大一在代码知识方面的积累，速成了html，JavaScript等语言的基础知识，又经过一番检索，了解到了<a href="https://easyhexo.com/">hexo</a>这样一个简单易用的个人博客网站框架。就这样，一个简陋的个人网站便搭好了。</p><h1>未来</h1><p>由于个人技术力的不足，现在这个网站还十分简陋。等到未来随着水平的逐渐提高，再来慢慢完善吧。</p><ul><li>以后可能会写的文章类型<ul><li>独处时胡思乱想出来的一些想法</li><li>阅读文章后的心得体会</li><li>记录有趣事情的短记</li><li>记录外出增长见识经历的游记</li><li>也可能会当做随时随地可翻看的笔记本，写一些技术分享。</li></ul></li></ul><p>由于这篇文章是由数个短暂的摸鱼时刻编写拼凑而成，所以可能语言显得毫无章法。<s>比较符合当代大学生复习时的精神状态</s></p><p>非常感谢你能耐心地看到这里</p><p>本篇完</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前言&lt;/h1&gt;
&lt;p&gt;期中考试周终于结束了😇&lt;/p&gt;
&lt;p&gt;此处应该配图&lt;/p&gt;
&lt;div class=&quot;fj-gallery&quot;&gt;&lt;p&gt;&lt;img src=&quot;/photo/kddzc.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
          &lt;/div&gt;
&lt;p&gt;其实这篇文章断</summary>
      
    
    
    
    <category term="随记" scheme="https://blog.weswei.com/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="随想" scheme="https://blog.weswei.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
</feed>
